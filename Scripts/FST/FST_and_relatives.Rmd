---
title: "FST and its relatives GST and Jost's D"
header-includes:
- \usepackage{xfrac}
- \usepackage{bm}
- \usepackage{float}
output:
  pdf_document: default
  word_document: default
bibliography: /Users/aimeet/Documents/BroadLaptop/Bibtex/library.bib
---


```{r setup, include=FALSE}
# Default chunk options
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE, cache.comments = FALSE, fig.pos = 'H', fig.width = 6)

```

# Summary

GST is the multi-allelic equivalent of Wright’s FST as defined by @Nei1973. Estimates of GST and of Wright’s FST as defined by Nei, hereafter referred to as Nei's estimator, are therefore identical when based on biallelic data, such as the barcode and WGS data used in the current study (Fig \ref{fig:GST=FST barcode} and \ref{fig:GST=FST WGS}), and do not correlate with distance, neither naively (Fig \ref{fig:GST distance barcode} and \ref{fig:GST distance WGS}) nor when using the transformation predicted to give a linear relationship under a two-dimensional isolation by distance model [@Rousset1997] (Fig \ref{fig:GST distance barcode rousset 2d} and \ref{fig:GST distance WGS rousset 2d}). 

Estimates generated by Nei's estimator [@Nei1973] differ to estimates generated using Hudson’s FST estimator (Fig \ref{fig: FST nei versus hudson estimators barcode} and \ref{fig: FST nei versus hudson estimators WGS}). This is because Hudson’s estimator is based on Weir and Hill’s definition of Wright’s FST [@Weir2002a], where the denominator is defined relative to an ancestral population, whereas Nei defined FST relative to present populations (as reviewed by @Bhatia2013). The latter is also true of the more commonly used estimator of @Weir1984. We use Hudson’s estimator to estimate FST because it is robust for unbalanced sample sizes [@Willing2012; @Bhatia2013], where as the more commonly used estimator of @Weir1984 is not. Moreover, Hudson’s estimator was designed for multi-loci data, being asymptotically consistent in the number of loci [@Reich2009; @Bhatia2013]. 

In contrast to bi-allelic FST, which is bounded by 0 and 1, within population diversity (such as that caused by high mutation rates) limits the upper bound of multi-allelic GST, hampering its interpretation, as discussed in [@Whitlock2011; @Meirmans2011]. Jost’s D is an alternative measure of differentiation, intended to overcome problems associated with GST and its relatives [@Jost2008]. According to @Meirmans2011, Jost's perceived problems included the aforementioned restricted range, as well as additive variance and the heterozygosity basis of diversity. Jost thus proposed a normalized measure of allelic differentiation, assuming multiplicative variance, where diversity is based on the effective number of alleles, essentially resulting in a logistic relationship between diversity and heterozygosity [@Meirmans2011]. 

There are numerous issues with Jost’s D [@Whitlock2011], especially when assuming convergence under the island model of migration [@Meirmans2011]. However, the most relevant issue here is its application to SNP data, which can lead to counterintuitive results, since SNPs have at most four allelic states [@Meirmans2011]. Another complication is that Jost’s D was designed as a single-locus measure (Josts'D is highly locus-specific, being dependent on the mutation rate, which varies over multiallelic loci, e.g. microsatellites, for which Jost’s D was formulated). Nevertheless, following suggestions in [@Meirmans2011], we calculated Jost’s D using average heterozygosities (as described at length below). Fig \ref{fig: D distance WGS} to \ref{fig: D distance WGS rousset} show that there is no relationship between estimates of Jost’s D and distance based on the barcode nor WGS data, neither when considered naively, nor when using the transformation predicted to give a linear relationship under the two-dimensional model of isolation by distance [@Rousset1997].

In summary, we have shown here that there is little evidence of a relationship between distance and estimates of GST and Jost’s D based on data from the Thai-Myanmar border. We have not included these results in the revised manuscript, however, since we are working with biallelic data sets (both barcode and WGS) over multiple loci, and thus do not feel GST nor Jost’s D are appropriate measures. 


# Methods and plots

<!-- %============================================================================ -->
## $F_{ST}$ definition
<!-- %============================================================================ -->
There are many different definitions and estimators of FST. In our manuscript, we used Hudson's estimator [@Hudson1992a], whose explicit formulation was outlined first in the supplementary information of @Reich2009, and later in [@Bhatia2013], where it was fist coined "the Hudson estimator". In the limit of large sample sizes, the Hudson estimator does not depend on the ratio of sample sizes [@Bhatia2013], whereas the most commonly used estimator of @Weir1984 does (assuming population-wise FST estimates as defined @Weir2002a are unequal), and so is liable to inflate FST estimates [@Bhatia2013]. The Hudson estimator as also been shown numerically to perform well when the ratio is high and the minimum sample size is small [@Willing2012]. This is important because Hudson's estimator is typically used by the Reich lab to study ancient DNA samples, which are rare (personal communication). Its relationship to other commonly used estimators is explored both theoretically and numerically in @Bhatia2013. Here we show its relationship to estimates of $G_{ST}$ [@Nei1973] and Jost's $D$ [@Jost2008]. We focus on multi-locus estimates, because estimates from single SNPS are highly liable to inflation given the small and unequal sample sizes. 


<!-- %============================================================================ -->
## Parameter definition
<!-- %============================================================================ -->
Parameters $G_{ST}$ [@Nei1973], $G'_{ST}$ [@Hedrick2005] and Jost's $D$ [@Jost2008] (reviewed in @Whitlock2011) can all be defined using total and within population heterozygosity ($H_T$ and $H_S$, respectively) as outlined in @Meirmans2011 (but here taking $k$ of @Meirmans2011 to be equal to $2$, since we are only interested in pairwise comparisons),  

\begin{align}
G_{ST} &= \sfrac{H_T - H_S}{H_T}, \\
G'_{ST} &= \sfrac{G_{ST}(1 + H_S)}{1 - H_s},\\
D &= 2 \sfrac{H_T - H_S}{1-H_S}. 
\end{align}

Based on @NEI1983, taking $w_i = \sfrac{1}{2}$ (assuming equal relative population size), $r = 2$ and $s = 2$ (since we are working with pairwise comparisons of biallelic data), and using $p_i$ and $q_i$ to denote $p_{i\; k = 1}$ and $p_{i \;k = 2}$ of @NEI1983 (that is to say, $p$ denotes one allele frequency and $q = 1-p$ the other, while numerical subscripts denote populations),  

\begin{align}
H_S &= \sfrac{1}{2} \big\{ (1 - p_1^2 - q_1^2) + (1 - p_2^2 - q_2^2) \big\}, \label{eq HS} \\
H_T &= 1 - \Big(\sfrac{p_1 + p_2}{2} \Big)^2 - \Big(\sfrac{q_1 + q_2}{2}\Big)^2. \label{eq HT}
\end{align}

We note that 
\begin{align}
H_S &= \sfrac{1}{2} \big\{ (1 - p_1^2 - q_1^2) + (1 - p_2^2 - q_2^2) \big\}, \nonumber \\
 &= \sfrac{1}{2} \big\{2 p_1 (1-p_1) + 2 p_2 (1-p_2) \big\} \nonumber \\
 &= \sfrac{1}{2} \big\{ 2h_1 + 2h_2 \big\}, \nonumber\\
 &= h_1 + h_2. \label{eq: HS H1 H2}
\end{align}

Where $2h_1$ and $2h_2$ are the heterozygosities for a given marker in populations 1 and 2, respectively, following notation in @Reich2009. And that
\begin{align}
H_T &= 1 - \Big(\sfrac{p_1 + p_2}{2} \Big)^2 - \Big(\sfrac{q_1 + q_2}{2}\Big)^2, \nonumber \\
 &= 1 - \sfrac{1}{4}\big((p_1 + p_2)^2 - (q_1 + q_2)^2 \big). \label{eq: HT psum2 pdiff2} 
\end{align}

<!-- %====================================================================== -->
## Parameter estimation
<!-- %====================================================================== -->
Following @Meirmans2011, we estimate $G_{ST}$, $G_{ST}$ and Jost's $D$ using unbiased estimates of $H_S$ and $H_T$,
\begin{align}
\hat{G}_{ST} &= \sfrac{\hat{H}_T - \hat{H}_S}{\hat{H}_T}, \\
\hat{G}'_{ST} &= \sfrac{\hat{G}_{ST}(1 + \hat{H}_S)}{1 - \hat{H}_s},\\
\hat{D} &= 2 \sfrac{\hat{H}_T - \hat{H}_S}{1-\hat{H}_S},  
\end{align}
where $\hat{H}_T = \sum_{k = 1}^M \hat{H}_T^{[k]}$ and $\hat{H}_S = \sum_{k = 1}^M \hat{H}_S^{[k]}$ and $\hat{H}_T^{[k]}$ and $\hat{H}_S^{[k]}$ are unbiased estimates at the $k$th SNP of the within-population and total heterozygosity, respectively. For consistency with our estimates of $F_{ST}$, we construct $\hat{H}_T^{[k]}$ and $\hat{H}_S^{[k]}$ following @Reich2009. Specifically, fixing $k$, we estimate $H_S$ (as defined in equation \eqref{eq: HS H1 H2}) using, 

\begin{align}
\hat{H}_S = \hat{h}_1 + \hat{h}_2, \label{eq HS unbiased}
\end{align}

where $\hat{h}_1$ and $\hat{h}_2$ are unbiased estimators of $h_1$ and $h_2$ introduced via equation 9 of @Reich2009. Note that $2\hat{h}_i = \hat{H}_{S_i}$ of equation 7 in @NEI1983 if $H_{0i}$ of @NEI1983 is zero. However, equation \eqref{eq HS unbiased} above does not equal equation 9 of @NEI1983, where the latter is only approximately unbiased as remarked upon in @Reich2009. Similarly, our estimate of $H_T$ outlined below differs from equation 11 of @NEI1983. 

We unbiasedly estimate $H_T$ for a given marker (as defined in equation \eqref{eq: HT psum2 pdiff2}), using unbiased estimators of $(p_1 + p_2)^2$ and $(q_1 + q_2)^2$, which we denote $\hat{U}$ and $\hat{V}$, respectively,  

\begin{align}
\hat{H}_T = 1 - \dfrac{\hat{U}}{4} - \dfrac{\hat{V}}{4}. 
\end{align}

The unbiased estimates $\hat{U}$ and $\hat{V}$,  

\begin{align}
\hat{U} = \Big(\sfrac{a_1}{n_1} + \sfrac{a_2}{n_2} \Big)^2 - \sfrac{\hat{h}_1}{n_1} - \sfrac{\hat{h}_2}{n_2}, \\
\hat{V} = \Big(\sfrac{b_1}{n_2} + \sfrac{b_2}{n_1} \Big)^2 - \sfrac{\hat{h}_1}{n_1} - \sfrac{\hat{h}_2}{n_2},
\end{align}
are constructed following the same reasoning used to construct $\hat{N}$ of equation 10 in @Reich2009). 


<!-- %============================================================================ -->
## $\hat{U}$ and $\hat{V}$ are unbiased  
<!-- \label{sec: unbiased} -->
<!-- %============================================================================ -->

<!-- %---------------------------------------------------------------------------- -->
### Analytical results
<!-- %---------------------------------------------------------------------------- -->

Let $Y = \Big(\sfrac{a_1}{n_1} + \sfrac{a_2}{n_2} \Big)^2$ be a naive estimate of $(p_1 + p_2)^2$ and $X = \Big(\sfrac{b_1}{n_1} + \sfrac{b_2}{n_2} \Big)^2$ be a naive estimate of $(q_1 + q_2)^2$, then 

\begin{align}
E[Y] &= E\Big[\Big(\sfrac{a_1}{n_1} + \sfrac{a_2}{n_2} \Big)^2 \Big], \nonumber \\
&= E\Big[\Big\{ \Big( \sfrac{a_1}{n_1} - p_1 \Big) + \Big(\sfrac{a_2}{n_2} - p_2 \Big) + (p_1 + p_2) \Big\}^2 \Big], \nonumber \\
&= E\Big[\Big(\sfrac{a_1}{n_1} - p_1\Big)^2  + \Big(\sfrac{a_2}{n_2} - p_2 \Big)^2 + (p_1 + p_2)^2 \nonumber  \\
&+ 2\Big(\sfrac{a_1}{n_1} - p_1\Big)\Big(\sfrac{a_2}{n_2} - p_2\Big) + 2\Big(\sfrac{a_1}{n_1} - p_1\Big)(p_1 + p_2) + 2\Big(\sfrac{a_2}{n_2} - p_2\Big)(p_1 + p_2)\Big], \label{eq: EY long}\\ 
&= E\Big[\Big(\sfrac{a_1}{n_1} - p_1\Big)^2\Big]  + E\Big[\Big(\sfrac{a_2}{n_2} - p_2 \Big)^2\Big] + (p_1 + p_2)^2,  \label{eq: EY short} \\
&= Var\Big[\sfrac{a_1}{n_1}\Big] +  Var\Big[\sfrac{a_2}{n_2}\Big] + (p_1 + p_2)^2,  \nonumber \\
&= \sfrac{1}{n_1^2}Var[a_1] +  \sfrac{1}{n_2^2}Var[a_2] + (p_1 + p_2)^2, \label{eq: EY var short} \\
&= \sfrac{p_1(1-p_1)}{n_1} + \sfrac{p_2(1-p_2)}{n_2} + (p_1 + p_2)^2, \label{eq: EY var long} \\
&= \sfrac{h_1}{n_1} + \sfrac{h_2}{n_2} + (p_1 + p_2)^2, \nonumber 
\end{align}

assuming from equation \eqref{eq: EY long} to \eqref{eq: EY short}, that the covariance $E \big[ \big(\sfrac{a_1}{n_1} - p_1\big)\big(\sfrac{a_2}{n_2} - p_2\big) \big] = 0$ and noting that $E \big[2\big(\sfrac{a_1}{n_1} - p_1\big)(p_1 + p_2)\big] = 2(p_1 + p_2)\big\{E\big[\sfrac{a_1}{n_1}\big] - p_1 \big\}= 0$ and likewise for $E \Big[2 \big(\sfrac{a_1}{n_1} - p_1\Big)(p_1 + p_2)\big]$, and assuming from \eqref{eq: EY var short} to \eqref{eq: EY var long}, that $a_1$ and $a_2$ are binomially distributed, where $h_1$ and $h_2$ are defined above. And similarly for $X$, such that, 

\begin{align}
E[X] 
&= E\Big[\Big\{ \Big( \sfrac{b_1}{n_1} - q_1 \Big) + \Big(\sfrac{b_2}{n_2} - q_2 \Big) + (q_1 + q_2) \Big\}^2 \Big], \nonumber \\
&= E\Big[\Big(\sfrac{b_1}{n_1} - q_1\Big)^2  + \Big(\sfrac{b_2}{n_2} - q_2 \Big)^2 + (q_1 + q_2)^2 \nonumber  \\
&+ 2\Big(\sfrac{b_1}{n_1} - q_1\Big)\Big(\sfrac{b_2}{n_2} - q_2\Big) + 2\Big(\sfrac{b_1}{n_1} - q_1\Big)(q_1 + q_2) - 2\Big(\sfrac{b_2}{n_2} - q_2\Big)(q_1 + q_2)\Big], \nonumber \\ 
&= Var\Big[\sfrac{b_1}{n_1}\Big] +  Var\Big[\sfrac{b_2}{n_2}\Big] + (q_1 + q_2)^2,  \nonumber \\
&= \sfrac{h_2}{n_2} + \sfrac{h_1}{n_1} + (q_1 + q_2)^2, \nonumber 
\end{align}

noting that $Var[b_1] = Var[a_1]$ and likewise for $b2$. Given $E[Y]$ and $E[X]$, and the fact that $\hat{h}_1$ and $\hat{h}_2$ are unbiased estimators of $h_1$ and $h_2$, respectively, it is easy to show that $\hat{U}$ and $\hat{V}$ are unbiased estimates of $(p_1 + p_2)^2$ and $(q_1 + q_2)^2$, respectively, 

\begin{align}
E\big[\hat{U} \big]
&= E\Big[\Big(\sfrac{a_1}{n_1} + \sfrac{a_2}{n_2} \Big)^2 - \sfrac{\hat{h}_1}{n_1} - \sfrac{\hat{h}_2}{n_2}\Big], \nonumber \\
&= E\Big[Y - \sfrac{\hat{h}_1}{n_1} - \sfrac{\hat{h}_2}{n_2}\Big], \nonumber \\
&= E[Y] - E[\sfrac{\hat{h}_1}{n_1}] - E[\sfrac{\hat{h}_2}{n_2}], \nonumber  \\
&= \sfrac{h_1}{n_1} + \sfrac{h_2}{n_2} + (p_1 + p_2)^2 - \sfrac{h_1}{n_1} - \sfrac{h_2}{n_1}, \nonumber\\
&= (p_1 + p_2)^2. \nonumber \\ \nonumber \\
E\big[\hat{V} \big]
&= E\Big[\Big(\sfrac{b_1}{n_1} + \sfrac{b_2}{n_2} \Big)^2 - \sfrac{\hat{h}_1}{n_1} - \sfrac{\hat{h}_2}{n_2}\Big], \nonumber\\
&= E\Big[X - \sfrac{\hat{h}_1}{n_1} - \sfrac{\hat{h}_2}{n_2}\Big], \nonumber\\
&= E[X] - E[\sfrac{\hat{h}_1}{n_1}] - E[\sfrac{\hat{h}_2}{n_2}], \nonumber\\
&= \sfrac{h_1}{n_1} + \sfrac{h_2}{n_2} + (q_1 + q_2)^2 - \sfrac{h_1}{n_1} - \sfrac{h_2}{n_1}, \nonumber\\
&= (q_1 + q_2)^2. \nonumber
\end{align}


<!-- %-------------------------------------------------------------------------------- -->
### Numerical results
<!-- %-------------------------------------------------------------------------------- -->
To illustrate the unbiased nature of $\hat{H}^{[k]}_S$ and $\hat{H}^{[k]}_T$, in this section we plot average results from increasingly many independent experiments, each with independent draws of $a_1$ and $a_2$ from binomial distributions with fixed $p_1$ and $n_1$, and $p_2$ and $n_2$.

```{r, echo=FALSE, message=FALSE, cache=TRUE, fig.cap=paste("Numerical verification of unbiased heteroygosity estimates")}
########################################################################
# Numerically compare estimators of HS and HT based on 
# Nei and Chesser 1983 
# Reich et al. 2009
# And naive estimates
########################################################################
# Set some parameters
set.seed(1) # For reproducibility
p1 <- 0.4
p2 <- 0.3
n1 <- 10
n2 <- 12
nrepeats <- seq(10, 5000, length.out = 20) 

# Calculate true
HS_true <- 0.5*(1 - p1^2 - (1-p1)^2 + 1 - p2^2 - (1-p2)^2)
HT_true <- 1 - (0.5*(p1 + p2))^2 - (0.5*((1-p1) + (1-p2)))^2

# Allocate store for means
HS <- HT <- array(dim = c(length(nrepeats),3))

#=======================================================================
# Simulate
#=======================================================================
for(i in 1:length(nrepeats)){
  
  # Create temporary stores
  HS_naive <- rep(NA, nrepeats[i])
  HS_NandC <- rep(NA, nrepeats[i])
  HS_our <- rep(NA, nrepeats[i])
  HT_naive <- rep(NA, nrepeats[i])
  HT_NandC <- rep(NA, nrepeats[i])
  HT_our <- rep(NA, nrepeats[i])
  
  for(j in 1:nrepeats[i]){
    
    a1 <- rbinom(1, prob = p1, size = n1)
    a2 <- rbinom(1, prob = p2, size = n2)
    b1 <- n1 - a1
    b2 <- n2 - a2
    harmonic_n <- 1/mean(c(1/n1, 1/n2))
    
    # HS: Naive estimate
    HS_naive[j] <- 0.5*(1 - (a1/n1)^2 - (b1/n1)^2 + 1  - (a2/n2)^2 - (b2/n2)^2)  
    
    # HS: Equation 9 of Nei and Chesser 1983 (assuming H0 = 0, since haploid)
    HS_NandC[j] <- (harmonic_n/(harmonic_n - 1)) * (1 - 0.5*((a1/n1)^2 + (a2/n2)^2) - 0.5*((b1/n1)^2 + (b2/n2)^2))
    
    # HS: Estimate based on Reich et al. 2009
    HS_our[j] <- 0.5*((n1/(n1-1))*(1 - (a1/n1)^2 - (b1/n1)^2)  +  (n2/(n2-1))*(1 - (a2/n2)^2 - (b2/n2)^2))
    
    # HT: Naive estimate
    HT_naive[j] <- 1 - (0.5*(a1/n1 + a2/n2))^2 - (0.5*(b1/n1 + b2/n2))^2
    
    # HT: Equation 11, Nei and Chesser 193 (assuming H0 = 0 since haploid)
    HT_NandC[j] <- 1 - (0.5*((a1/n1)+(a2/n2)))^2 - (0.5*((b1/n1)+(b2/n2)))^2 + HS_NandC[j]/(2*harmonic_n) 
    
    # HT: Estimate based on Reich et al. 2009
    Uhat <- ((a1/n1) + (a2/n2))^2 - a1*(n1-a1)/(n1^2*(n1-1)) - a2*(n2-a2)/(n2^2*(n2-1))
    Vhat <- ((b1/n1) + (b2/n2))^2 - a1*(n1-a1)/(n1^2*(n1-1)) - a2*(n2-a2)/(n2^2*(n2-1))
    HT_our[j] <- 1 - 0.25*Uhat - 0.25*Vhat
    
  }
  HS[i,] <- c(mean(HS_naive), mean(HS_NandC), mean(HS_our)) 
  HT[i,] <- c(mean(HT_naive), mean(HT_NandC), mean(HT_our))
  
}



#=======================================================================
# Plot
#=======================================================================
par(mfrow = c(1,2))
plot(NULL, ylim = range(HS), xlim = range(nrepeats), 
     ylab = 'Estimate', xlab = 'Number of repeats', 
     bty = 'n', pch = 20, main = expression(H[S]))
abline(h = HS_true)
for(i in 1:3){
  points(y = HS[,i], x = nrepeats, pch = i, cex = 0.5)  
}
legend('top', legend = c('Naive','Nei & Chesser 1983', 'Reich et al. 2009'), 
       bty = 'n', pch = 1:3, cex  = 0.75)

plot(NULL, ylim = range(HT), xlim = range(nrepeats), 
     ylab = 'Estimate', xlab = 'Number of repeats', 
     bty = 'n', pch = 20, main = expression(H[T]))
abline(h = HT_true)
for(i in 1:3){
  points(y = HT[,i], x = nrepeats, pch = i, cex = 0.5)  
}
legend('top', legend = c('Naive','Nei & Chesser 1983', 'Reich et al. 2009'), 
       bty = 'n', pch = 1:3, cex  = 0.75)

```


```{r include=FALSE}
# Load packages, data and function scripts
rm(list = ls())
source('../../FunctionFiles/mymantel.rtest.R')
source('../../FunctionFiles/calculate_pairwise_Fst.R')
load('../../RData/geo_dist_info.RData')
attach(geo_dist_info, warn.conflicts = FALSE)
Pair_wise_site_comparisons <- pairwise_site_distance[,c(1,2)]
numComparisons <- nrow(Pair_wise_site_comparisons)
estimators <- c('Reich')

# Load WGS
load(file = '../../RData/Data_store_WGS.RData')
attach(Data_store, warn.conflicts = FALSE)
# Load Barcode
load('../../RData/Data_store_Barcode.RData')
Data_store_barcode <- Data_store 
```

```{r echo=FALSE, cache=TRUE, message=FALSE}
# ============================================================================ 
# Function to calculate FST (Copied from calculate_pairwise_Fst.R Aug 31st 2017)
# and unbiased estimates of HS, HT, and estimates of GST, G'ST, Jost's D
# ============================================================================ 
calculate_pairwise_reich_and_relatives <- function(P1, P2, SNPDataBinary){ 
  
  # Data where n1 and n2 are considered fixed and a1 and a2 are considered binomially distributed random variables 
  n1 <- apply(SNPDataBinary[P1,], 2, FUN = function(x){sum(!is.na(x))})
  n2 <- apply(SNPDataBinary[P2,], 2, FUN = function(x){sum(!is.na(x))})
  a1 <- colSums(SNPDataBinary[P1,], na.rm = TRUE)
  a2 <- colSums(SNPDataBinary[P2,], na.rm = TRUE)
  
  # Estimator of Fst proposed in supplementary of Reich et al. 
  diff_sqrd_p_naive <- (colMeans(SNPDataBinary[P1,], na.rm = TRUE) - colMeans(SNPDataBinary[P2,], na.rm = TRUE))^2
  h1_unbiasd <- (a1*(n1-a1))/(n1*(n1-1)) 
  h2_unbiasd <- (a2*(n2-a2))/(n2*(n2-1))
  N_unbiasd <- diff_sqrd_p_naive - (h1_unbiasd/n1) - (h2_unbiasd/n2)
  D_unbiasd <- N_unbiasd + h1_unbiasd + h2_unbiasd
  F_st <- N_unbiasd/D_unbiasd 
  F_st_Wright <- N_unbiasd/(D_unbiasd + h1_unbiasd + h2_unbiasd)
  
  # Unbiased estimators of HS and HT (following notation and unbiased estimates of h1 and h2 in Riech)
  sum_sqrd_p_naive <- (colMeans(SNPDataBinary[P1,], na.rm = TRUE) + colMeans(SNPDataBinary[P2,], na.rm = TRUE))^2
  sum_sqrd_q_naive <- ((1-colMeans(SNPDataBinary[P1,], na.rm = TRUE)) + (1-colMeans(SNPDataBinary[P2,], na.rm = TRUE)))^2
  sum_sqrd_p_unbiasd <- sum_sqrd_p_naive - (h1_unbiasd/n1) - (h2_unbiasd/n2)
  sum_sqrd_q_unbiasd <- sum_sqrd_q_naive - (h1_unbiasd/n1) - (h2_unbiasd/n2)
  HS_unbiasd <- h1_unbiasd + h2_unbiasd 
  HT_unbiasd <- 1 - sum_sqrd_p_unbiasd/4 - sum_sqrd_q_unbiasd/4 
  
  # GST, G'ST, Jost's D and G'ST(nei), G''ST (correcting for small k) 
  # following approach in Meirmans and Hedrick 2011
  GST = (HT_unbiasd - HS_unbiasd)/HT_unbiasd # unlabed in Meirmans and Hedrick 2011 because Nei's
  GdashST = (GST*(1 + HS_unbiasd))/(1 - HS_unbiasd) # eq 1 of Meirmans and Hedrick 2011
  JostsD = 2*(HT_unbiasd - HS_unbiasd)/(1 - HS_unbiasd) # eq 2 of Meirmans and Hedrick 2011
  GdashST_Nei = 2*(HT_unbiasd - HS_unbiasd)/(2*HT_unbiasd - HS_unbiasd) # unlabelled in Meirmans and Hedrick 2011 because Nei's
  GdashdashST = GdashST_Nei/(1-HS_unbiasd) # eq 2 of Meirmans and Hedrick 2011
  
  # Snps to remove
  snps_with_too_few_data <- as.logical(colSums(rbind(n1,n2) < 4)) # Are any sample sizes < 4? 
  invariant_snps <- (a1 == n1 | a2 == n2) # Are there any non-variant X? snps_with_too_few_data return NA
  NAsnps <- (invariant_snps | snps_with_too_few_data) 
  
  # Average quantities
  F_st_av <- sum(N_unbiasd[!NAsnps])/sum(D_unbiasd[!NAsnps])
  F_st_Wright_av <-  sum(N_unbiasd[!NAsnps])/sum(D_unbiasd[!NAsnps] + h1_unbiasd[!NAsnps] + h2_unbiasd[!NAsnps])
  HS_unbiasd_av <- mean(HS_unbiasd[!NAsnps])
  HT_unbiasd_av <- mean(HT_unbiasd[!NAsnps])
  GST_av = (HT_unbiasd_av - HS_unbiasd_av)/HT_unbiasd_av # unlabed in Meirmans and Hedrick 2011 because Nei's
  GdashST_av = (GST_av*(1 + HS_unbiasd_av))/(1 - HS_unbiasd_av) # eq 1 of Meirmans and Hedrick 2011
  JostsD_av = 2*(HT_unbiasd_av - HS_unbiasd_av)/(1 - HS_unbiasd_av) # eq 2 of Meirmans and Hedrick 2011
  GdashST_Nei_av = 2*(HT_unbiasd_av - HS_unbiasd_av)/(2*HT_unbiasd_av - HS_unbiasd_av) # unlabelled in Meirmans and Hedrick 2011 because Nei's
  GdashdashST_av = GdashST_Nei_av/(1-HS_unbiasd_av) # eq 2 of Meirmans and Hedrick 2011
  
  
  return(list(F_st_snp = F_st,
              F_st_Wright_snp = F_st_Wright, 
              HS_snp = HS_unbiasd, 
              HT_snp = HT_unbiasd, 
              GST_snp = GST, 
              GdashST_snp = GdashST,  
              JostsD_snp = JostsD,  
              GdashST_Nei_snp = GdashST_Nei,  
              Gdashdash_snp = GdashdashST, 
              F_st = F_st_av,
              F_st_Wright = F_st_Wright_av, 
              HS = HS_unbiasd_av, 
              HT = HT_unbiasd_av, 
              GST = GST_av, 
              GdashST = GdashST_av,  
              JostsD = JostsD_av,  
              GdashST_Nei = GdashST_Nei_av,  
              GdashdashST = GdashdashST_av
  ))
}


# ============================================================================
# Generate point estimates using WGS (takes ~ 5 seconds)
# ============================================================================
Pairwise_results_WGS <- vector('list', length = length(geo_order))
names(Pairwise_results_WGS) <- geo_order
#system.time(
  for(i in 1:numComparisons){
    P1 <- MetaDataSubset$collection_location  == as.character(Pair_wise_site_comparisons[i,1])
    P2 <- MetaDataSubset$collection_location  == as.character(Pair_wise_site_comparisons[i,2])
    Pairwise_results_WGS[[i]] <- calculate_pairwise_reich_and_relatives(P1, P2, SNPDataSubset)
  }
#)

# ============================================================================
# Generate point estimates using Barcode (takes < 14 second)
# ============================================================================
Pairwise_results_barcode <- vector('list', length = length(geo_order))
names(Pairwise_results_barcode) <- geo_order
#system.time(
  for(i in 1:numComparisons){
    P1 <- (Data_store_barcode$Data_no_multiclonal[,4] == as.character(Pair_wise_site_comparisons[i,1]))
    P2 <- (Data_store_barcode$Data_no_multiclonal[,4] == as.character(Pair_wise_site_comparisons[i,2]))
    Pairwise_results_barcode[[i]] <- calculate_pairwise_reich_and_relatives(P1, P2, Data_store_barcode$SNPData_no_multiclonal)
  }
#)

```


```{r functions, echo=FALSE, cache=TRUE}
# A function for captioning and referencing images
fig <- local({
    i <- 0
    ref <- list()
    list(
        cap=function(refName, text) {
            i <<- i + 1
            ref[[refName]] <<- i
            paste("Fig ", i, ": ", text, sep="")
        },
        ref=function(refName) {
            ref[[refName]]
        })
})

# Transformation recommended in [Rousset (1997). Genetics]
Rousset <- function(p){return(p/(1-p))} 
```

```{r, echo=FALSE, cache=TRUE}
set.seed(1) # for reproducibility of the p-values
par(mar = c(5,5,1,1))
```

```{r, echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig:GST=FST barcode}Equality of estimates of Nei's definition of Wright's FST and GST based on barcode data.")}
#----------------------------------------------------------------------------
# Equality of Wright's FST and GST based on barcode
#----------------------------------------------------------------------------
plot(x = do.call(c, sapply(Pairwise_results_barcode, function(x){x['F_st_Wright']})), 
     y = do.call(c, sapply(Pairwise_results_barcode, function(x){x['GST']})),
     xlab = expression('Nei\'s estimator of Wright\'s F'[ST]), 
     ylab = expression(G[ST]~'estimate'), 
     bty = 'n',pch = 21, bg = 'gray', main = '')
abline(a = 0, b = 1)
```

```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig:GST=FST WGS}Equality of estimates of Nei's definition of Wright's FST and GST based on WGS data.")}
#----------------------------------------------------------------------------
# Equality of Wright's FST and GST based on WGS
#----------------------------------------------------------------------------
plot(x = do.call(c, sapply(Pairwise_results_WGS, function(x){x['F_st_Wright']})), 
     y = do.call(c, sapply(Pairwise_results_WGS, function(x){x['GST']})),
     xlab = expression('Nei\'s estimator of Wright\'s F'[ST]), 
     ylab = expression(G[ST]~'estimate'), 
     bty = 'n',pch = 21, bg = 'gray', main = '')
abline(a = 0, b = 1)
```


```{r, echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig:GST distance barcode}GST estimates and distance: barcode data, no transformation.")}
#----------------------------------------------------------------------------
# GST and distance: barcode naive 
#----------------------------------------------------------------------------
# Plot
Y <- do.call(c, sapply(Pairwise_results_barcode, function(x){x['GST']}))
plot(x = pairwise_site_distance$distance, y = Y,
     xlab = 'Distance (km)', 
     ylab = expression(G[ST]~'estimate'), 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- pairwise_site_distance$distance, nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```


```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig:GST distance WGS}GST estimates and distance: WGS data, no transformation.")}
#----------------------------------------------------------------------------
# GST and distance: WGS naive
#----------------------------------------------------------------------------
Y <- do.call(c, sapply(Pairwise_results_WGS, function(x){x['GST']}))
plot(x = pairwise_site_distance$distance, y = Y,
     xlab = 'Distance (km)', 
     ylab = expression(G[ST]~'estimate'), 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- pairwise_site_distance$distance, nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```


```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig:GST distance barcode rousset 2d}GST estimates and distance: barcode data, using the transformation predicted to give a linear relationship under a two-dimensional isolation by distance model (Rousset 1997).")}
#----------------------------------------------------------------------------
# GST and distance: barcode Rousset transformation
#----------------------------------------------------------------------------
Y <- Rousset(do.call(c, sapply(Pairwise_results_barcode, function(x){x['GST']})))
plot(x = log(pairwise_site_distance$distance), y = Y,
     xlab = 'Log( distance (km))', 
     ylab = expression(G[ST] / (1-G[ST])~'estimate'), 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- log(pairwise_site_distance$distance), nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```

```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig:GST distance WGS rousset 2d}GST estimates and distance: WGS data, using the transformation predicted to give a linear relationship under a two-dimensional isolation by distance model (Rousset 1997).")}
#----------------------------------------------------------------------------
# GST and distance: barcode naive 
#----------------------------------------------------------------------------
Y <- Rousset(do.call(c, sapply(Pairwise_results_WGS, function(x){x['GST']})))
plot(x = log(pairwise_site_distance$distance), y = Y,
     xlab = 'Log( distance (km))', 
     ylab = expression(G[ST] / (1-G[ST])~'estimate'), 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- log(pairwise_site_distance$distance), nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```

```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig: FST nei versus hudson estimators barcode}FST estimates: barcode data.")}
#----------------------------------------------------------------------------
# Inequality of FST estimates based on definitions from Nei and Weir and Hill
#----------------------------------------------------------------------------
par(mfrow = c(1,1))
plot(y = do.call(c, sapply(Pairwise_results_barcode, function(x){x['F_st']})), 
     x = do.call(c, sapply(Pairwise_results_barcode, function(x){x['F_st_Wright']})),
     ylab = expression(F[ST]~'estimate using Nei\'s estimator'), 
     xlab = expression(F[ST]~'estimate using Hudson\'s estimator'), 
     bty = 'n',pch = 21, bg = 'gray')
```

```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig: FST nei versus hudson estimators WGS}FST estimates: WGS data.")}
#----------------------------------------------------------------------------
# Inequality of FST estimates based on definitions from Nei and Weir and Hill
#----------------------------------------------------------------------------
par(mfrow = c(1,1))
plot(y = do.call(c, sapply(Pairwise_results_WGS, function(x){x['F_st']})), 
     x = do.call(c, sapply(Pairwise_results_WGS, function(x){x['F_st_Wright']})),
     ylab = expression(F[ST]~'estimate using Nei\'s estimator'), 
     xlab = expression(F[ST]~'estimate using Hudson\'s estimator'), 
     bty = 'n',pch = 21, bg = 'gray')
```

```{r, echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig: D distance barcode}Jost's D estimates and distance: barcode data, no transformation.")}
#----------------------------------------------------------------------------
# Jost's D and distance: barcode naive 
#----------------------------------------------------------------------------
# Plot
Y <- do.call(c, sapply(Pairwise_results_barcode, function(x){x['JostsD']}))
plot(x = pairwise_site_distance$distance, y = Y,
     xlab = 'Distance (km)', 
     ylab = 'Jost\'s D estimate', 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- pairwise_site_distance$distance, nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```


```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig: D distance WGS}Jost's D estimates and distance: WGS data, no transformation.")}
#----------------------------------------------------------------------------
# Jost's D and distance: WGS naive
#----------------------------------------------------------------------------
Y <- do.call(c, sapply(Pairwise_results_WGS, function(x){x['JostsD']}))
plot(x = pairwise_site_distance$distance, y = Y,
     xlab = 'Distance (km)', 
     ylab = 'Jost\'s D estimate', 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- pairwise_site_distance$distance, nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```


```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig: D distance barcode rousset}Jost's D estimates and distance: barcode datausing the transformation predicted to give a linear relationship under a two-dimensional isolation by distance model (Rousset 1997).")}
#----------------------------------------------------------------------------
# Jost's D and distance: barcode Rousset transformation
#----------------------------------------------------------------------------
Y <- Rousset(do.call(c, sapply(Pairwise_results_barcode, function(x){x['JostsD']})))
plot(x = log(pairwise_site_distance$distance), y = Y,
     xlab = 'Log( distance (km))', 
     ylab = 'Jost\'s D / (1-Jost\'s D) estimate', 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- log(pairwise_site_distance$distance), nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```

```{r,  echo=FALSE, cache=TRUE, fig.cap=paste("\\label{fig: D distance WGS rousset}Jost's D estimates and distance: WGS data using the transformation predicted to give a linear relationship under a two-dimensional isolation by distance model (Rousset 1997).")}
#----------------------------------------------------------------------------
# GST and distance: barcode naive 
#----------------------------------------------------------------------------
Y <- Rousset(do.call(c, sapply(Pairwise_results_WGS, function(x){x['JostsD']})))
plot(x = log(pairwise_site_distance$distance), y = Y,
     xlab = 'Log( distance (km))', 
     ylab = 'Jost\'s D / (1-Jost\'s D) estimate', 
     bty = 'n',pch = 21, bg = 'gray')

# Trend with distance and annotate
Result <- mymantel_lm(m1 <- Y, m2 <- log(pairwise_site_distance$distance), nrepet = 1000)
legend('center', legend = bquote(beta == .(signif(Result$obs, 3)) ~ ('p-value' == .(signif(1-Result$pvalue,3)))), bty = 'n', pch = NULL)
text(y = 0.02, x = 50, labels = )
rm(Y)
```



<!-- ## Additional Results -->

```{r, include=FALSE}
#----------------------------------------------------------------------
# Average results WGS: estimates against estimates accounting for k
# As recommended in Meirmans2011
#----------------------------------------------------------------------
par(mfrow = c(1,2))
# GST versus G'GST Nei
plot(x = do.call(c, sapply(Pairwise_results_WGS, function(x){x['GST']})), 
     y = do.call(c, sapply(Pairwise_results_WGS, function(x){x['GdashST_Nei']})),
     xlab = expression('G\''[ST (Nei)]), 
     ylab = expression(G[ST]), 
     bty = 'n',pch = 21, bg = 'gray')

# G'ST versus G''ST 
plot(x = do.call(c, sapply(Pairwise_results_WGS, function(x){x['GdashST']})), 
     y = do.call(c, sapply(Pairwise_results_WGS, function(x){x['GdashdashST']})),
     xlab = expression('G\''[ST]), 
     ylab = expression('G\'\''[ST]), 
     bty = 'n',pch = 21, bg = 'gray')
```


```{r, include=FALSE}
#----------------------------------------------------------------------
# Average results WGS: FST and G'ST against distance
#----------------------------------------------------------------------
par(mfrow = c(1,2))
plot(x = pairwise_site_distance$distance, 
     y = do.call(c, sapply(Pairwise_results_WGS, function(x){x['F_st']})),
     ylab = expression(F[ST]), 
     xlab = 'Distance (km)', 
     bty = 'n',pch = 21, bg = 'gray')

plot(x = pairwise_site_distance$distance, 
     y = do.call(c, sapply(Pairwise_results_WGS, function(x){x['GdashST']})),
     xlab = 'Distance (km)',
     ylab = expression('G\''[ST]), 
     bty = 'n',pch = 21, bg = 'gray')
```


```{r, include=FALSE}
#-----------------------------------------------------------------------
# Average results barcode: FST and G'ST against distance
#-----------------------------------------------------------------------
par(mfrow = c(1,2))
plot(x = pairwise_site_distance$distance, 
     y = do.call(c, sapply(Pairwise_results_barcode, function(x){x['F_st']})),
     ylab = expression(F[ST]), 
     xlab = 'Distance (km)', 
     bty = 'n',pch = 21, bg = 'gray')

plot(x = pairwise_site_distance$distance, 
     y = do.call(c, sapply(Pairwise_results_barcode, function(x){x['GdashST']})),
     xlab = 'Distance (km)',
     ylab = expression('G\''[ST]), 
     bty = 'n',pch = 21, bg = 'gray')
```

\pagebreak


# References